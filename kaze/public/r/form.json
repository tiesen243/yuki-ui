{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "form",
  "type": "registry:ui",
  "title": "Form",
  "author": "tiesen243 <ttien56906@gmail.com>",
  "description": "A form component built from scratch that works with Standard Schema",
  "dependencies": [
    "@radix-ui/react-slot"
  ],
  "files": [
    {
      "path": "registry/ui/form.tsx",
      "content": "import * as React from 'react'\nimport { Slot } from '@radix-ui/react-slot'\n\nimport { cn } from '@/lib/utils'\n\ninterface FormError<TValue extends Record<string, unknown>> {\n  message?: string\n  issues?: Record<keyof TValue, string>\n}\n\ntype ChangeEvent =\n  | React.ChangeEvent<HTMLInputElement>\n  | string\n  | number\n  | boolean\n\ninterface FormFieldContextValue<\n  TValue extends Record<string, unknown>,\n  TName extends keyof TValue = keyof TValue,\n> {\n  field: {\n    name: TName\n    value: TValue[TName]\n    onChange: (event: ChangeEvent) => void\n    onBlur: (event: React.FocusEvent<HTMLInputElement>) => Promise<void> | void\n  }\n  state: {\n    isPending: boolean\n    hasError: boolean\n    error?: string\n  }\n  meta: {\n    id: string\n    formItemId: string\n    formDescriptionId: string\n    formMessageId: string\n  }\n}\n\nconst FormFieldContext = React.createContext<FormFieldContextValue<\n  Record<string, unknown>\n> | null>(null)\n\nfunction useFormField<\n  TForm extends ReturnType<typeof useForm>,\n  TName extends keyof TForm['state']['value'] = keyof TForm['state']['value'],\n>() {\n  const formField = React.use(\n    FormFieldContext,\n  ) as unknown as FormFieldContextValue<TForm['state']['value'], TName> | null\n  if (!formField)\n    throw new Error('useFormField must be used within a FormField')\n  return formField\n}\n\nfunction useForm<\n  TValue extends Record<string, unknown>,\n  TSchema extends StandardSchemaV1 | ((value: TValue) => TValue),\n  TData,\n  TError extends FormError<TValue>,\n>({\n  defaultValues,\n  validator,\n  onSubmit,\n  onSuccess,\n  onError,\n}: {\n  defaultValues: TValue\n  validator?: TSchema extends StandardSchemaV1\n    ? Required<InferInput<TSchema>> extends TValue\n      ? TSchema\n      : Types<TValue>['input']\n    : (value: TValue) => Result<TValue>\n  onSubmit: (value: TValue) => TData | Promise<TData>\n  onSuccess?: (data: TData) => void | Promise<void>\n  onError?: (error: TError) => void | Promise<void>\n}) {\n  const formValueRef = React.useRef<TValue>(defaultValues)\n  const formDataRef = React.useRef<TData | null>(null)\n  const formErrorRef = React.useRef<TError>(null)\n\n  const [isPending, startTransition] = React.useTransition()\n\n  const validateField = React.useCallback(\n    async <TKey extends keyof TValue>(\n      fieldKey?: TKey,\n      fieldValue?: TValue[TKey],\n    ): Promise<\n      | { isValid: true; data: TValue }\n      | { isValid: false; errors: Record<keyof TValue, string> }\n    > => {\n      const valueToValidate = fieldKey\n        ? { ...formValueRef.current, [fieldKey]: fieldValue }\n        : formValueRef.current\n\n      if (!validator) return { isValid: true, data: valueToValidate }\n\n      let validationResult: Result<TValue> | null = null\n      if (typeof validator === 'function') {\n        validationResult = validator(valueToValidate)\n      } else {\n        validationResult = await (validator as StandardSchemaV1<TValue>)[\n          '~standard'\n        ].validate(valueToValidate)\n      }\n\n      if (validationResult.issues) {\n        const errors = validationResult.issues.reduce(\n          (errorMap, issue) => {\n            errorMap[issue.path as unknown as keyof TValue] = issue.message\n            return errorMap\n          },\n          {} as Record<keyof TValue, string>,\n        )\n        return { isValid: false, errors }\n      }\n      return { isValid: true, data: validationResult.value }\n    },\n    [validator],\n  )\n\n  const handleSubmit = React.useCallback(() => {\n    startTransition(async () => {\n      formDataRef.current = null\n      formErrorRef.current = null\n\n      const validationResult = await validateField()\n      if (!validationResult.isValid) {\n        formErrorRef.current = { issues: validationResult.errors } as TError\n        return\n      }\n\n      try {\n        const result = await onSubmit(validationResult.data)\n        formDataRef.current = result\n        await onSuccess?.(result)\n      } catch (error) {\n        formDataRef.current = null\n        const message = error instanceof Error ? error.message : 'Unknown error'\n        formErrorRef.current = { message } as TError\n        await onError?.({ message } as TError)\n      }\n    })\n  }, [onError, onSubmit, onSuccess, validateField])\n\n  const Field = React.useCallback(\n    function FormField<TFieldName extends keyof TValue>({\n      name,\n      render,\n    }: {\n      name: TFieldName\n      render: (\n        props: FormFieldContextValue<TValue, TFieldName>,\n      ) => React.ReactNode\n    }) {\n      const [value, setValue] = React.useState(formValueRef.current[name])\n      const prevValueRef = React.useRef(value)\n\n      const [error, setError] = React.useState(\n        formErrorRef.current?.issues?.[name] ?? '',\n      )\n\n      const parseValue = React.useCallback((target: HTMLInputElement) => {\n        switch (target.type) {\n          case 'number':\n            return target.valueAsNumber as TValue[TFieldName]\n          case 'checkbox':\n            return target.checked as TValue[TFieldName]\n          case 'date':\n            return target.valueAsDate as TValue[TFieldName]\n          default:\n            return target.value as TValue[TFieldName]\n        }\n      }, [])\n\n      const handleChange = React.useCallback(\n        (event: ChangeEvent) => {\n          const newValue =\n            typeof event === 'object' && 'target' in event\n              ? parseValue(event.target)\n              : (event as TValue[TFieldName])\n\n          setValue(newValue)\n\n          React.startTransition(() => {\n            formValueRef.current[name] = newValue\n          })\n        },\n        [name, parseValue],\n      )\n\n      const handleBlur = React.useCallback(async () => {\n        if (prevValueRef.current === value) return\n        prevValueRef.current = value\n\n        const results = await validateField(name, value)\n        if (!results.isValid && results.errors[name])\n          setError(results.errors[name])\n        else setError('')\n      }, [name, value])\n\n      const id = React.useId()\n\n      const formFieldContextValue = React.useMemo(\n        () =>\n          ({\n            field: { name, value, onChange: handleChange, onBlur: handleBlur },\n            state: { isPending, hasError: !!error, error },\n            meta: {\n              id,\n              formItemId: `${id}-form-item`,\n              formDescriptionId: `${id}-form-item-description`,\n              formMessageId: `${id}-form-item-message`,\n            },\n          }) satisfies FormFieldContextValue<TValue, TFieldName>,\n        [error, handleBlur, handleChange, id, name, value],\n      )\n\n      return (\n        <FormFieldContext value={formFieldContextValue as never}>\n          {render(formFieldContextValue)}\n        </FormFieldContext>\n      )\n    },\n    [isPending, validateField],\n  )\n\n  const Label = React.useCallback(function FormLabel({\n    className,\n    ...props\n  }: React.ComponentProps<'label'>) {\n    const { state, meta } = useFormField<never>()\n\n    return (\n      <label\n        data-slot=\"form-label\"\n        htmlFor={meta.formItemId}\n        aria-disabled={state.isPending}\n        aria-invalid={state.hasError}\n        className={cn(\n          'text-sm leading-none font-medium',\n          'aria-disabled:cursor-not-allowed aria-disabled:opacity-70',\n          'aria-invalid:text-destructive',\n          className,\n        )}\n        {...props}\n      />\n    )\n  }, [])\n\n  const Control = React.useCallback(function FormControl({\n    className,\n    ...props\n  }: React.ComponentProps<'input'>) {\n    const { state, meta } = useFormField()\n\n    return (\n      <Slot\n        data-slot=\"form-control\"\n        id={meta.formItemId}\n        aria-describedby={\n          !state.hasError\n            ? meta.formDescriptionId\n            : `${meta.formDescriptionId} ${meta.formMessageId}`\n        }\n        aria-invalid={state.hasError}\n        aria-disabled={state.isPending}\n        className={cn(\n          'aria-disabled:cursor-not-allowed aria-disabled:opacity-70',\n          className,\n        )}\n        {...props}\n      />\n    )\n  }, [])\n\n  const Description = React.useCallback(function FormDescription({\n    children,\n    className,\n    ...props\n  }: React.ComponentProps<'span'>) {\n    const { meta } = useFormField()\n\n    return (\n      <span\n        data-slot=\"form-description\"\n        id={meta.formDescriptionId}\n        className={cn('text-muted-foreground text-sm', className)}\n        {...props}\n      >\n        {children}\n      </span>\n    )\n  }, [])\n\n  const Message = React.useCallback(function FormMessage({\n    children,\n    className,\n    ...props\n  }: React.ComponentProps<'span'>) {\n    const { state, meta } = useFormField()\n    const body = state.hasError ? String(state.error) : children\n\n    return (\n      <span\n        data-slot=\"form-message\"\n        id={meta.formMessageId}\n        className={cn('text-destructive text-sm', className)}\n        {...props}\n      >\n        {body}\n      </span>\n    )\n  }, [])\n\n  const reset = React.useCallback(() => {\n    Object.assign(formValueRef.current, defaultValues)\n    formErrorRef.current = null\n    formDataRef.current = null\n  }, [defaultValues])\n\n  return React.useMemo(\n    () => ({\n      Field,\n      Label,\n      Control,\n      Description,\n      Message,\n      handleSubmit,\n      reset,\n\n      state: {\n        isPending,\n        hasError: !!formErrorRef.current,\n        value: formValueRef.current,\n        data: formDataRef.current,\n        error: formErrorRef.current,\n      },\n    }),\n    [\n      Control,\n      Description,\n      Field,\n      Label,\n      Message,\n      handleSubmit,\n      isPending,\n      reset,\n    ],\n  )\n}\n\nexport { useForm }\n\n/** The Standard Schema interface. */\ninterface StandardSchemaV1<Input = unknown, Output = Input> {\n  /** The Standard Schema properties. */\n  readonly '~standard': Props<Input, Output>\n}\n\ninterface Props<Input = unknown, Output = Input> {\n  /** The version number of the standard. */\n  readonly version: 1\n  /** The vendor name of the schema library. */\n  readonly vendor: string\n  /** Validates unknown input values. */\n  readonly validate: (\n    value: unknown,\n  ) => Result<Output> | Promise<Result<Output>>\n  /** Inferred types associated with the schema. */\n  readonly types?: Types<Input, Output> | undefined\n}\n\n/** The result interface of the validate function. */\ntype Result<Output> = SuccessResult<Output> | FailureResult\n\n/** The result interface if validation succeeds. */\ninterface SuccessResult<Output> {\n  /** The typed output value. */\n  readonly value: Output\n  /** The non-existent issues. */\n  readonly issues?: undefined\n}\n\n/** The result interface if validation fails. */\ninterface FailureResult {\n  /** The issues of failed validation. */\n  readonly issues: readonly Issue[]\n}\n\n/** The issue interface of the failure output. */\ninterface Issue {\n  /** The error message of the issue. */\n  readonly message: string\n  /** The path of the issue, if any. */\n  readonly path?: readonly (PropertyKey | PathSegment)[] | undefined\n}\n\n/** The path segment interface of the issue. */\ninterface PathSegment {\n  /** The key representing a path segment. */\n  readonly key: PropertyKey\n}\n\n/** The Standard Schema types interface. */\ninterface Types<Input = unknown, Output = Input> {\n  /** The input type of the schema. */\n  readonly input: Input\n  /** The output type of the schema. */\n  readonly output: Output\n}\n\n/** Infers the input type of a Standard Schema. */\ntype InferInput<Schema extends StandardSchemaV1> = NonNullable<\n  Schema['~standard']['types']\n>['input']\n",
      "type": "registry:ui"
    }
  ]
}